let spec = `

what Stuff is (~~ brackio)
   it seems to go to form:
    Modus of advancing states with methods (~~ Super)
    Selection (~~ C**, nodes)
     types of hierarchy (edges)
      ie whether theyre basically all up or down
      the clone|mirror plane...
      origin
      continuity of identity (~~ resolve $n)
       this is going too far!

just want a nice light medium to CRUD with
    for the thinky process supporting music piracy
    that can be persisted, somewhat...






use cases:
  build a scheme to
   inflate and annotate a directory tree
    slow the directory listing iterator

`


export class Stuff {

}


`
      =write or read (autovivificatorialy)
        X/$someindex ||= x += /$n
       leading to x, another|inside X via $someindex
       x doesnt know what indexes it is in
        &Xsomp etc make ax = {someindex=value,x,n...}
        joins|varies by x.z/r aka x/$n or just /$n,
         the members being added to x locatable space
       < X_n, X_z for duplicating|not X.z?
      =cut 
`
        # the X/$t += r
        # r could be Y, s (C), X|x, anything
        # in &RbitXarrive it is R, &brackX it is a row
        me.X_t = &acgtXtrk{
            k ||= 't'
            X[k] ||= {}
            $x = X[k][t] ||= {};
            x.up = X
            x.z ||= [];
            r && x.z.push(r)
            return x
        }
        # (car,'i',a) dupey accumulator, like /$n (rows at x)
        me.X_z = &acgtXkr{
            $N = X[k] ||= []
            !isar(N) and throw "!ar"
            N.push(r)
            return r
        }
        # the X/uniq($s) += r
        me.oX_s = &acgtXsr,kf,q,{
            q ||= {}
            q.el = 8
            return me&X_s,X,s,r,kf,q
        }
        me.X_s = &acgtXsr,kf,q,{
            kf ||= 's'
            return me&X_refer,X,s,r,kf,0,q
        }
        me.X_refer = &acgtXsr,kf,kfs,q,{
            !kf and throw "named"
            kfs ||= kf+'s'
            # by id of the value
            $fs = X[kfs] ||= [];
            $vi = fs.indexOf(s);
            q && q.el == 8 && vi < 0 and return
            vi < 0 and vi = fs.push(s)-1
            $f = X[kf] ||= [];
            $x = f[vi] ||= {};
            x.up = X
            x.z ||= [];
            r && x.z.push(r);
            return x
        }
  

